
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Personal blog by Thomas F McGeehan V">
      
      
        <meta name="author" content="Thomas F McGeehan V">
      
      
        <link rel="canonical" href="https://tfmv.github.io/blog/blog-posts/arrow-ecosystem/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.25">
    
    
      
        <title>Introduction - Blog - Thomas F McGeehan V</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function n(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],n("js",new Date),n("config",""),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){this.value&&n("event","search",{search_term:this.value})}),document$.subscribe(function(){var a=document.forms.feedback;if(void 0!==a)for(var e of a.querySelectorAll("[type=submit]"))e.addEventListener("click",function(e){e.preventDefault();var t=document.location.pathname,e=this.getAttribute("data-md-value");n("event","feedback",{page:t,data:e}),a.firstElementChild.disabled=!0;e=a.querySelector(".md-feedback__note [data-md-value='"+e+"']");e&&(e.hidden=!1)}),a.hidden=!1}),location$.subscribe(function(e){n("config","",{page_path:e.pathname})})});var e=document.createElement("script");e.async=!0,e.src="https://www.googletagmanager.com/gtag/js?id=",document.getElementById("__analytics").insertAdjacentElement("afterEnd",e)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
      
        <meta  property="og:type"  content="website" >
      
        <meta  property="og:title"  content="Introduction - Blog - Thomas F McGeehan V" >
      
        <meta  property="og:description"  content="Personal blog by Thomas F McGeehan V" >
      
        <meta  property="og:image"  content="https://tfmv.github.io/blog/assets/images/social/blog-posts/arrow-ecosystem.png" >
      
        <meta  property="og:image:type"  content="image/png" >
      
        <meta  property="og:image:width"  content="1200" >
      
        <meta  property="og:image:height"  content="630" >
      
        <meta  property="og:url"  content="https://tfmv.github.io/blog/blog-posts/arrow-ecosystem/" >
      
        <meta  name="twitter:card"  content="summary_large_image" >
      
        <meta  name="twitter:title"  content="Introduction - Blog - Thomas F McGeehan V" >
      
        <meta  name="twitter:description"  content="Personal blog by Thomas F McGeehan V" >
      
        <meta  name="twitter:image"  content="https://tfmv.github.io/blog/assets/images/social/blog-posts/arrow-ecosystem.png" >
      
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="pink">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#introduction" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Blog - Thomas F McGeehan V" class="md-header__button md-logo" aria-label="Blog - Thomas F McGeehan V" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Blog - Thomas F McGeehan V
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Introduction
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="pink"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="cyan"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/TFMV/blog" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../flight/" class="md-tabs__link">
          
  
    
  
  Blog

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Blog - Thomas F McGeehan V" class="md-nav__button md-logo" aria-label="Blog - Thomas F McGeehan V" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Blog - Thomas F McGeehan V
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/TFMV/blog" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../flight/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Arrow Flight
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../go-arrow/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Go and Arrow
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../unilateral-bond/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Unilateral Bond
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../quiver/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quiver
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../billion/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Billion
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">#</a></h1>
<p>Apache Arrow, Arrow Flight, and Arrow Flight SQL form a layered stack for high-performance data analytics. Apache Arrow defines a language-agnostic in-memory columnar format, optimized for speed and zero-copy sharing. Arrow Flight builds an RPC framework on top of Arrow, using gRPC to transmit Arrow data efficiently between processes or across networks. Arrow Flight SQL adds a SQL protocol layer over Flight, allowing clients to execute SQL queries on remote data sources with Arrow as the transport. This paper examines each layer’s architecture and implementation in depth, focusing on memory layout, serialization, RPC mechanisms, and cross-language design, with illustrative code snippets and diagrams.</p>
<ol>
<li>Apache Arrow: In-Memory Columnar Format<br />
Columnar Memory Layout: Apache Arrow defines a standardized in-memory format for tabular data, stored column-by-column rather than row-by-row. Each column (or Array) consists of one or more contiguous memory buffers plus minimal metadata (length, null count, etc.). For example, a nullable 32-bit integer array of 5 elements would have: (a) a 64-bit length (5) and null count, and (b) two buffers – a validity bitmap indicating non-null entries, and a value buffer of 5 int32 values​<br />
ARROW.APACHE.ORG<br />
. The figure below illustrates this layout, with a validity bitmap (1 0 1 1 1 for values [1, NA, 2, 4, 8]) and the corresponding data buffer (the ints 1, 2, 4, 8, with NA represented by a 0 in the bitmap). The Arrow format pads and aligns buffers to 8 or 64-byte boundaries for efficient CPU access​<br />
WESM.GITHUB.IO<br />
​<br />
WESM.GITHUB.IO<br />
, ensuring each value can be accessed in O(1) time via pointer offset arithmetic​<br />
ARROW.APACHE.ORG<br />
.</li>
</ol>
<p>Memory layout of an Arrow int32 Array with 5 elements (including a null). The array’s metadata (gray) stores length and null count. Two buffers (dotted box) hold the validity bitmap and the actual data values. Bits in the bitmap (e.g. 10111) mark non-null values​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
.All Arrow buffers are 64-bit aligned in memory and padded to multiples of 8 bytes​<br />
WESM.GITHUB.IO<br />
 (and ideally 64 bytes for cache-line alignment​<br />
WESM.GITHUB.IO<br />
). This alignment enhances sequential scans and enables use of SIMD (Single Instruction, Multiple Data) CPU instructions on contiguous values. The Arrow format is explicitly designed to be “SIMD and vectorization-friendly”​<br />
ARROW.APACHE.ORG<br />
, so analytics libraries can operate on whole chunks of data with one CPU instruction. Arrow’s spec mandates little-endian encoding for multi-byte values, and values are stored in their native binary form (e.g. 4 bytes for int32), eliminating translation overhead​<br />
WESM.GITHUB.IO<br />
.Zero-Copy and Immutability: A key feature of Arrow’s design is that data can be shared between processes and languages without serialization or copying, often referred to as zero-copy sharing. Because Arrow uses relative offsets instead of absolute pointers internally, memory can be remapped in another process address space “without pointer swizzling”, i.e. without altering pointer values​<br />
ARROW.APACHE.ORG<br />
. This means an Arrow array in C++ can be sent to Python or Java simply by passing the memory buffers (via shared memory or memory mapping), and the consumer can interpret it directly as Arrow data. Arrow arrays are immutable once created, to avoid concurrency issues; any “mutation” creates new arrays under the hood​<br />
WESM.GITHUB.IO<br />
. This immutability and standardized layout enable consistent sharing. For cross-language data sharing in-memory, Arrow provides the C Data Interface, a C struct API that lets one language hand off Arrow memory to another safely (for example, PyArrow (Python) can consume an Arrow C++ array via this interface). For persistent or remote transfer, Arrow defines an IPC (Inter-Process Communication) format using FlatBuffers to serialize schema and chunk metadata​<br />
ARROW.APACHE.ORG<br />
, while still dumping raw column buffers as-is. This IPC format (Arrow file or stream) is implemented in each language’s library for reading/writing Arrow data to disk or sockets.Language Implementations (C++, Rust, Go, etc.): Arrow’s format is language-agnostic, and there are implementations in C++, Java, Rust, Python (C++ bindings), Go, and more, all adhering to the Arrow columnar spec​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. In C++, Arrow is implemented with classes like arrow::Array, arrow::Buffer, and arrow::RecordBatch, with memory allocated from a MemoryPool (which ensures alignment and may use huge pages). Buffers in C++ are reference-counted (via std::shared_ptr) to manage lifetimes safely across arrays. Rust’s implementation (in the arrow-rs crate) similarly defines an ArrayData struct that holds buffer pointers and metadata for an array​<br />
ARROW.APACHE.ORG<br />
. Rust uses Arc for buffer memory and unsafe code to guarantee 64-bit alignment when allocating memory for Arrow buffers. Go’s Arrow library uses Go slices ([]byte) under the hood for buffers and follows the same buffer layout (validity bitmap, offsets, etc.), with care taken to pad and align as required by the spec. Because all implementations use the same physical layout, an Arrow file written in C++ can be memory-mapped and then read in Rust or Go without parsing. The Arrow C++ library also offers a “C Stream” interface and integration components so that (for example) a Rust Arrow iterator can stream data to a C++ consumer purely in memory.Vectorized Execution and SIMD: The columnar layout of Arrow lends itself to vectorized processing. Operations can be applied to entire buffers with tight for-loops that the CPU can optimize with instruction pipelining and vector instructions. Arrow’s compute kernels (e.g. for array arithmetic, filtering, aggregation) are often optimized with SIMD. Arrow C++ uses runtime CPU feature detection to dispatch to the best available instructions – e.g. if AVX2 is available, use 256-bit wide operations, otherwise fall back to SSE4.2​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. This is configurable: setting ARROW_USER_SIMD_LEVEL=AVX2 can force Arrow to use AVX2 paths, for instance​<br />
ARROW.APACHE.ORG<br />
. At compile time, Arrow enables a baseline of SSE4.2 optimizations (which means the library won’t run on older CPUs lacking those instructions by default)​<br />
ARROW.APACHE.ORG<br />
. An example of a SIMD-optimized operation is Arrow’s memory comparison or sum functions, which load 8 or 16 values at a time into vector registers. In Rust, some of these optimizations are leveraged through LLVM’s auto-vectorization or explicit use of libraries; for example, the Arrow Rust implementation has had experiments with the packed_simd crate to speed up kernels like parsing or math operations, though the performance gains depend on the scenario. Overall, the Arrow format ensures data locality (values of one column are adjacent in memory) which maximizes CPU cache efficiency and enables modern superscalar and SIMD execution to significantly accelerate analytics​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
.Interoperability and IPC: Arrow’s format was designed for interoperability across systems. Besides in-memory sharing, the Arrow IPC mechanism serializes data in a streaming or file format. Under the hood this uses the same memory layout: record batches are encoded as a small FlatBuffer Message header (with metadata like schema, buffer sizes, etc.) followed by the raw concatenated buffers. This means writing Arrow data to disk or sending over a socket doesn’t require per-value processing – it’s essentially dumping the memory as bytes. Arrow Flight (next section) actually uses this IPC format for sending data. Many frameworks use Arrow as a bridge: for example, a C++ process can send an Arrow RecordBatch over shared memory to Python (PyArrow) without converting types, or a Go program can read a Feather/Arrow file written by R. In summary, Apache Arrow provides the foundation: a portable columnar memory format with strong alignment, efficient null representation (bitmaps), and zero-copy shareability, implemented consistently in multiple languages. This foundation is leveraged by Arrow Flight to build high-speed communication.<br />
2. Arrow Flight: High-Performance RPC for Arrow<br />
Overview and Architecture: Arrow Flight is an RPC framework for transferring Arrow data between processes or over the network with minimal overhead​<br />
ARROW.APACHE.ORG<br />
. It is built on top of gRPC (Google’s HTTP/2 RPC framework) and uses Arrow’s IPC format as the payload for data streams​<br />
ARROW.APACHE.ORG<br />
. The core idea is to avoid the usual serialization cost when sending large datasets: since both sender and receiver understand the Arrow format, Flight can send Arrow record batches as-is. Flight organizes data transfer around streams of Arrow record batches (called FlightData streams). A client can download data from a Flight server (using a DoGet operation) or upload data (using DoPut), and both sides can do so in parallel thanks to gRPC’s bidirectional streaming​<br />
ARROW.APACHE.ORG<br />
. Flight also provides metadata RPCs for discovering what data is available and controlling the transfer.In the Flight protocol, datasets are identified by a FlightDescriptor (either a textual path or an opaque command)​<br />
ARROW.APACHE.ORG<br />
. For example, a FlightDescriptor might contain a SQL query or a file path as the “command” identifying a data set. Clients use a two-step process to retrieve data: first, call GetFlightInfo with a descriptor to get a FlightInfo result describing the dataset (including its schema and endpoints), then call DoGet with a Ticket (from the FlightInfo) to actually stream the Arrow record batches​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. This two-phase approach allows the server to inform the client about dataset size, schema, and possibly multiple endpoints for parallel transfer (more on that below). Additional RPC methods include ListFlights (to list available datasets on the server), GetSchema (to fetch schema without data), and DoAction/ListActions (to perform custom commands outside of data transfer, e.g. cache control)​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. There is also DoExchange, a bidirectional full-duplex stream for advanced use cases (where client and server send Arrow data to each other simultaneously over one channel). Flight’s design exploits gRPC streaming so that large datasets can be sent as a sequence of Arrow messages without re-establishing connections​<br />
ARROW.APACHE.ORG<br />
.The diagram below shows a simple Flight retrieval flow: a client requests a dataset by calling GetFlightInfo, the server responds with a FlightInfo (which includes a ticket and location), and then the client calls DoGet to fetch the data stream as Arrow FlightData messages.</p>
<p>Arrow Flight simple client-server flow​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. The client first calls GetFlightInfo with a descriptor; the server returns a FlightInfo (including schema and a data Ticket). The client then calls DoGet with that Ticket, and the server streams back a sequence of FlightData messages (Arrow record batches) over the network.Flight is designed for high throughput and parallelism. Flight servers can be part of a distributed cluster – for instance, one node might act as a planner/coordinator (handling metadata requests), and others as data nodes (serving the actual partitions of data). In such cases, a GetFlightInfo request to the coordinator can return multiple endpoints (each with a host address and ticket) in the FlightInfo. The client can then perform multiple DoGet calls in parallel to different endpoints to retrieve different partitions of the dataset concurrently​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. This pattern enables horizontal scaling: rather than funneling all data through one server, the client directly pulls from many servers. The Flight protocol natively supports this by allowing FlightInfo to contain a list of endpoints. (For example, Dremio’s distributed system uses a coordinator that returns multiple endpoints and yields 20-50x better throughput than single-node ODBC transfers​<br />
ARROW.APACHE.ORG<br />
.)(Optionally, a diagram of a distributed Flight setup with a planner node and multiple data nodes could be shown, illustrating parallel DoGet requests. In text form: A “planner” returns N endpoints in GetFlightInfo, and the client issues N DoGet calls to “data” servers in parallel.)gRPC and Protocol Buffers: Under the hood, Arrow Flight uses gRPC’s code-generated stubs from a protocol buffer definition. The Flight service is defined with RPC methods such as Handshake, ListFlights, GetFlightInfo, DoGet, DoPut, etc., in a Protocol Buffers schema​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. In proto terms, the critical message is FlightData, which encapsulates a chunk of Arrow data. Notably, FlightData has fields: a FlightDescriptor (only set on the first message of a stream), a data_header (which is the serialized Arrow IPC message header for a record batch), an app_metadata (optional user metadata), and the data_body (the raw bytes of the record batch)​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. The data_body is marked as field number 1000 in the proto, which is a trick to ensure it comes last – making it easier to treat as a payload “sidecar” that can be zero-copied​<br />
ARROW.APACHE.ORG<br />
. A Flight server, upon sending an Arrow record batch, will produce a FlightData message where data_header and data_body together contain the Arrow IPC representation of that batch. Because Arrow’s IPC format already has a tiny header (with metadata like field lengths, etc.) followed by raw buffers, the FlightData essentially wraps that.Zero-Copy Serialization in Flight: A major implementation goal of Flight is to avoid overhead in converting Arrow data to Protobuf and back. The Arrow developers implemented low-level optimizations in C++ and Java gRPC to achieve zero-copy transfers​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. Instead of letting the Protobuf library copy bytes into a new structure, the Flight implementations intercept the Arrow buffers and send them directly over gRPC. As Wes McKinney described, Flight can “generate the Protobuf wire format for FlightData including the Arrow record batch being sent without&hellip; intermediate memory copying or serialization”​<br />
ARROW.APACHE.ORG<br />
. On the receiving end, the implementation “reconstructs an Arrow record batch from the Protobuf representation&hellip; intercepting the encoded data payloads without allowing the Protobuf library to touch them.”​<br />
ARROW.APACHE.ORG<br />
. In practical terms, the C++ Flight server uses the gRPC C++ API to write the Arrow buffers as a series of grpc::Slice objects (which can point to existing memory) rather than serializing through the Protobuf reflection API. Similarly, Flight in Java uses Netty’s ByteBuf zero-copy features to send Arrow buffers directly. This way, Flight achieves near-hardware-limited throughput – internal tests report 2-3 GB/s on localhost for Arrow data via Flight (no TLS)​<br />
ARROW.APACHE.ORG<br />
, essentially the limit of memory copy over TCP. A consequence of this design is that even if a client is not Arrow-aware (just a generic gRPC client), it can still receive FlightData messages (as byte blobs) and decode them via Protobuf, but it would pay the cost of deserializing those large data_body fields. Flight’s optimized path is available when both sides use the Arrow Flight libraries, giving “have your cake and eat it too” performance – i.e. maximum speed for Arrow-aware clients, while preserving interoperability with any gRPC client if needed​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
.Language-Specific Implementations: Arrow Flight is implemented in multiple languages, typically building on each language’s gRPC library:<br />
C++: Arrow C++ provides arrow::flight::FlightServerBase and FlightClient classes. A developer implements a C++ Flight service by subclassing FlightServerBase and overriding its virtual methods for the RPC calls (e.g. ListFlights, GetFlightInfo, DoGet, etc.)​<br />
JORISVANDENBOSSCHE.GITHUB.IO<br />
​<br />
ARROW.APACHE.ORG<br />
. For example, one might override GetFlightInfo to accept a descriptor and return a corresponding FlightInfo (including schema and endpoints)​<br />
ARROW.APACHE.ORG<br />
. The base class handles the gRPC interaction under the hood, so your overrides receive high-level Arrow types (like a FlightDescriptor or a FlightMessageReader) instead of raw protobufs. On the client side, FlightClient exposes methods like ListFlights, DoGet (which returns an iterator of record batches), making consumption straightforward. The C++ implementation uses the gRPC C++ engine and registers a service that delegates to your FlightServerBase. Memory is managed with Arrow’s allocator and the zero-copy optimizations described above.<br />
Java: In Java, Arrow Flight provides similar facilities. A server implements the FlightProducer interface (or extends NoOpFlightProducer which provides no-op defaults)​<br />
ARROW.APACHE.ORG<br />
. This interface has methods corresponding to each Flight RPC (e.g. listFlights, getFlightInfo, doGet, etc.). The developer implements these, using Arrow Java libraries (VectorSchemaRoot for batches, etc.) to produce or consume Arrow data. To start a server, Arrow provides a FlightServer builder – you supply a network Location (host/port), an Allocator for Arrow buffers, and your FlightProducer implementation, then call server.start()​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. The client side is similarly straightforward: FlightClient.builder(&hellip;).build() gives a client that can call listFlights(), getStream() etc. as high-level methods​<br />
ARROW.APACHE.ORG<br />
. The Java Flight implementation uses gRPC Java under the hood. It also takes advantage of Arrow’s Java memory model (which uses direct ByteBuffers for off-heap memory) to avoid copies. For example, when sending a record batch, the Java implementation can write the Arrow buffers into the Netty channel directly. The Java API differs in style (since Java lacks multiple inheritance): rather than subclassing a base class, you implement callbacks in FlightProducer.<br />
Rust: Arrow Flight for Rust is provided by the arrow-flight crate (part of the Arrow Rust project). It is a native Rust implementation using Tonic (a Rust gRPC library) and Prost (a Protobuf compiler for Rust)​<br />
ARROW.APACHE.ORG<br />
. The crate includes generated structs for all Flight messages (e.g. FlightData, FlightInfo, etc.) and gRPC service traits for client and server (e.g. a generated FlightService trait that one implements)​<br />
ARROW.APACHE.ORG<br />
. For convenience, it also offers a higher-level FlightClient with async methods, and utilities to easily convert between Arrow RecordBatches and the FlightData stream​<br />
ARROW.APACHE.ORG<br />
. A Rust developer can use these to create a Flight server: implement the tonic-generated server trait for Flight (or use provided base implementations) and handle each method. The Rust implementation currently flags Flight SQL support as experimental (opt-in via a feature)​<br />
ARROW.APACHE.ORG<br />
, which parallels the evolving state of Flight SQL in Rust. Because Rust doesn’t have a stable ABI with C++, this Rust implementation is independent (not just bindings to C++). It manages memory using Arrow’s Rust memory model (which ensures buffers are aligned and uses ArrowBuffer internally). While Rust can leverage zero-copy for in-process data, the Tonic library will copy data into its own buffers when sending over the network (this is an area for potential optimization as Rust gRPC matures). In one comparison, Arrow’s C++ Flight outperformed the early Rust version due to such low-level optimizations not yet implemented in Rust​<br />
ARROW.APACHE.ORG<br />
, but work is ongoing.<br />
Go: The Go implementation of Arrow Flight (part of Apache Arrow Go) uses Go’s grpc library. The proto definition includes an option for the Go package​<br />
ARROW.APACHE.ORG<br />
, and Arrow’s Go module provides generated interfaces. A Go developer can implement the FlightServiceServer interface (generated by protoc) or more conveniently use Arrow Go’s provided server struct and callback registration. Like in other languages, Arrow Go’s flight server will handle marshalling Arrow RecordBatches to the FlightData protobuf. Go’s garbage-collected runtime doesn’t guarantee 100% zero-copy (there might be some copying when handing bytes to gRPC), but it strives to minimize it. The Go Arrow library uses []byte for buffers, and those can often be handed directly to gRPC as []byte without an extra encoding step. On the client side, Go provides a FlightClient that wraps gRPC calls, delivering Arrow RecordBatch data via channels or callback interfaces. (Python’s Flight implementation is just a binding to C++ – so Python users simply import pyarrow.flight and use the C++ underpinnings.)<br />
Memory Handling &amp; Serialization: We have touched on this, but to summarize: Arrow Flight’s prime directive is to send Arrow data without serialization overhead. By using the Arrow IPC format as the payload (embedded in the FlightData message), the server does not convert Arrow columns into some row-based format or JSON – it just wraps the existing Arrow buffers. The official Flight spec notes that the FlightData’s body is put as the last field to “help with sidecar patterns” so that some implementations can pull it off the wire efficiently​<br />
ARROW.APACHE.ORG<br />
. C++ and Java implementations indeed treat data_body as a sidecar: C++ uses grpc::WriteOptions::setNoCopy() with slices of the Arrow buffer memory​<br />
ARROW.APACHE.ORG<br />
, and Java uses Netty’s reference counted buffers. The result is that the overhead of the Flight layer is very small compared to raw socket I/O – as evidenced by throughput tests (multi-gigabyte per second transfers on 10 Gbit links)​<br />
ARROW.APACHE.ORG<br />
. Flight also supports optional compression for Arrow buffers (added in newer versions), but since Arrow data is often already compressed at column level (e.g. dictionary-encoded or run-length encoded), many use cases send it uncompressed.Use Cases: Arrow Flight is useful wherever large or streaming data needs to move between processes with low latency. Common scenarios include distributed query engines (offloading result set transfer to Flight instead of ODBC/JDBC), data services that serve Arrow tables to clients (for example, a Flight server in front of a Parquet dataset or a database), and stream processing where one service produces a stream of Arrow batches that consumers subscribe to. Because Flight can easily saturate network bandwidth, it’s suitable for high-speed data lake access or feeding Arrow data into AI/ML pipelines in real time. The Flight protocol also has built-in support for authentication and TLS encryption via gRPC, so it can be used securely in production (it includes a simple token-based auth and can be extended, plus it works with TLS just by using grpc+tls:// URIs​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
). Logging and monitoring can be integrated via gRPC interceptors (Arrow C++ integrates with OpenTelemetry for tracing Flight calls​<br />
ARROW.APACHE.ORG<br />
).In summary, Arrow Flight provides a RPC layer specialized for columnar data, leveraging Arrow’s format to eliminate serialization overhead. It is implemented in C++, Java, Rust, Go, and accessible in Python, with consistent semantics across these. With Flight, data engineers can treat remote data as Arrow tables and move them with unprecedented speed. The next layer, Arrow Flight SQL, builds on Flight to make interacting with databases via Arrow even easier.<br />
3. Arrow Flight SQL: SQL over Arrow Flight<br />
Overview of Flight SQL: Arrow Flight SQL is a relatively new protocol (introduced in Arrow 7.0.0) that extends Arrow Flight for database connectivity​<br />
ARROW.APACHE.ORG<br />
. It allows clients to execute SQL queries, prepare statements, and retrieve database metadata (tables, schemas, etc.) over Arrow Flight​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. In essence, it defines a standardized set of RPC calls and message types for SQL operations, using Arrow Flight’s efficient transport as the carrier. The goal is to provide an Arrow-native alternative to ODBC/JDBC – one that avoids the row-by-row data conversion overhead of those older interfaces​<br />
ARROW.APACHE.ORG<br />
. With Flight SQL, a client can talk to any database or query engine that implements the Flight SQL server API, and receive results as Arrow tables (which can be used directly in pandas, Spark, DataFrame libraries, etc., without copy). Flight SQL is not meant to replace SQL query languages or engines – rather, it’s a common wire protocol. A Flight SQL server is essentially a thin wrapper around a database or query engine: it receives Flight SQL requests (like “execute this query”), forwards them to the database internally, then streams the results back in Arrow format.Protocol and Commands: Flight SQL builds on the base Flight RPCs by using the concept of FlightDescriptor commands and Action messages to represent SQL requests. The Flight SQL spec defines a set of Command message types (Protobuf messages) for various operations​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
:<br />
Metadata queries (getting database/catalog info): e.g. CommandGetTables (list tables), CommandGetSchemas, CommandGetCatalogs, CommandGetSqlInfo (get DB capabilities), CommandGetPrimaryKeys, CommandGetExportedKeys etc.​<br />
ARROW.APACHE.ORG<br />
. These correspond to metadata calls akin to JDBC’s DatabaseMetaData functions.<br />
Executing queries: CommandStatementQuery for a direct SQL query (SELECT), and CommandStatementUpdate for an update (INSERT/UPDATE/DELETE) that returns an affected row count​<br />
ARROW.APACHE.ORG<br />
.<br />
Prepared statements: ActionCreatePreparedStatementRequest (client asks server to prepare a query), which returns an ActionCreatePreparedStatementResult containing a handle. Then CommandPreparedStatementQuery or CommandPreparedStatementUpdate can execute that prepared statement (with the given handle)​<br />
ARROW.APACHE.ORG<br />
. There’s also an ActionClosePreparedStatementRequest to close the handle.<br />
Under Flight SQL, a typical query execution goes through the standard Flight methods but with these special commands encapsulated. For example, to execute a SQL SELECT query, a client does: create a FlightDescriptor whose type is CMD and whose content is a serialized CommandStatementQuery (with the SQL string). It calls GetFlightInfo on the Flight server with this descriptor​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. The server sees the descriptor contains a SQL command, so it plans the query and doesn’t send data yet – it responds with a FlightInfo that includes schema (the schema of the result set) and a Ticket that represents the execution result. The client then calls DoGet with that Ticket​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
, and the server streams back the result set as Arrow record batches (FlightData). This is analogous to a JDBC client receiving a ResultSet, but here it’s all Arrow data. The above two-step (GetFlightInfo + DoGet) is necessary so the client can retrieve schema and potentially distribute the call (if the FlightInfo had multiple endpoints). In practice, libraries provide a simpler API (e.g. one call that wraps these steps).For a metadata request like listing tables, the pattern is the same: the client creates a descriptor with CommandGetTables (optionally specifying a filter or schema), calls GetFlightInfo, then DoGet to get the results (the list of tables as an Arrow table)​<br />
ARROW.APACHE.ORG<br />
. For an update that doesn’t return rows, the client can use DoGet which returns just a small batch (e.g. one row with the row count), or in some cases they might use DoAction for a confirmation.Prepared Statement Flow: Flight SQL’s prepared statements involve multiple RPCs and demonstrate how it layers on Flight’s existing calls. To prepare a statement, the client calls DoAction with an ActionCreatePreparedStatementRequest (containing the SQL)​<br />
ARROW.APACHE.ORG<br />
. The server responds (via the action result) with a handle (often just an integer or GUID identifier for the prepared statement on the server)​<br />
ARROW.APACHE.ORG<br />
. Now the client can bind parameters. Flight SQL expects the client to use DoPut for parameter binding: the client calls DoPut and the first message it sends has a descriptor of type CommandPreparedStatementUpdate (or Query) containing that prepared statement handle, and then it streams one or more Arrow record batches as the parameters for the parameterized query​<br />
ARROW.APACHE.ORG<br />
. The server executes the prepared statement for each set of parameters (or batch, depending on semantics) and can return a PutResult for each, including e.g. number of rows affected. Finally, the client issues a DoAction with ActionClosePreparedStatementRequest to clean up​<br />
ARROW.APACHE.ORG<br />
. While this is a bit intricate, it’s all built on the fundamental Arrow Flight streaming calls, just using specific message payloads to indicate what to do.Integration with Database Engines: A Flight SQL server needs to translate these Flight SQL calls into actual database operations. The implementation typically involves a server-side handler that implements a Flight SQL Producer interface. For instance, Arrow C++ provides a FlightSqlServerBase class (subclass of FlightServerBase) that already implements the base Flight RPCs and dispatches to new abstract methods for the SQL-specific commands​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. As the documentation notes, “Applications should subclass this class and override the virtual methods declared on this class.”​<br />
ARROW.APACHE.ORG<br />
. Those methods include things like ExecuteSqlQuery, GetTables, GetSqlInfo, etc., corresponding to the Flight SQL commands​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. The base class takes care of the boilerplate: for example, it overrides the base GetFlightInfo and DoGet (making them final) to intercept when a FlightDescriptor is actually a StatementQuery command and then calls your ExecuteSqlQuery override, etc.​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. This design simplifies custom servers: you focus on how to execute a given SQL command and produce Arrow data, and the Flight SQL framework wraps it into the Flight RPC flow.In Java, the Flight SQL support similarly will provide an interface (e.g. FlightSqlProducer) that extends the normal Flight FlightProducer. The Java implementation (as of Arrow 10) included a skeleton and is evolving; for example, there are helper classes to create a Flight SQL server by wrapping an existing JDBC data source, which can ease integration for databases that already have JDBC – but more efficiently, one would implement it natively. In Rust, as noted, Flight SQL is experimental: the Arrow Rust flight crate has a sql module​<br />
ARROW.APACHE.ORG<br />
, likely providing the protobuf definitions for the Flight SQL messages and maybe some helper for clients. A full Rust server would need to implement the Flight SQL protocol (perhaps using DataFusion as the query engine).Use with DuckDB, DataFusion, etc.: Flight SQL’s power is evident when integrating with modern embedded databases. For example, DuckDB (an in-process analytical database) has a native Arrow interface – it can output query results as Arrow record batches. A Flight SQL server can embed DuckDB: when it receives a CommandStatementQuery with some SQL, it forwards that SQL to DuckDB’s query runner (within the same process). DuckDB executes and produces an Arrow table in memory. The Flight SQL server then simply wraps those Arrow record batches and streams them out via Flight. Because DuckDB and Arrow Flight are both highly optimized in C++ and share memory, this yields a very fast pipeline – the data doesn’t need to be converted to rows or copied. In fact, DuckDB’s developers have showcased &gt;10x speedups in data transfer by using Flight SQL compared to client fetching via ODBC​<br />
DORIS.APACHE.ORG<br />
. Similarly, DataFusion (an Apache Arrow Rust query engine) can be put behind a Flight SQL server. DataFusion’s query results are already Arrow RecordBatches in Rust memory; a Rust Flight SQL server can take those and send them out directly. This essentially turns DataFusion into a SQL endpoint that Arrow clients (or tools via an Arrow ODBC driver) can query. Another example is Dremio and InfluxDB: Dremio has integrated Flight/Flight SQL to allow Arrow-based clients to retrieve data faster than ODBC. InfluxDB (time-series database) in its Cloud edition has added Flight SQL so that SQL queries to Influx return Arrow data frames efficiently​<br />
DOCS.INFLUXDATA.COM<br />
. Even traditional databases like MySQL or Postgres can benefit: an adapter can retrieve their results and present as Arrow via Flight SQL, avoiding the overhead of text or binary row protocols and then conversion to Arrow on the client.Client Side (Language Support): On the client side, Flight SQL is typically used via an official driver or API in each language. C++ and Java have Flight SQL client classes that wrap the generic FlightClient. For instance, C++ offers FlightSqlClient which has methods like Execute, GetTables, etc., and internally it serializes the appropriate protobuf and calls Flight RPCs (GetFlightInfo, DoGet) for you​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
. Python’s pyarrow.flight module now includes FlightSqlClient which allows a Python user to connect to a Flight SQL server and, for example, call .execute(&ldquo;SELECT * FROM table&rdquo;) and get a pyarrow.Table result – under the hood this uses the C++ Flight SQL client to perform the sequence of calls. There is also ongoing work on an ADBC (Arrow Database Connectivity) API, which is a higher-level abstraction where Flight SQL is one driver; however, focusing on implementation, Flight SQL is the wire protocol that ADBC would use for network connections.Performance Considerations: By using Flight SQL, the data path from database to client is fully columnar. This avoids the classic “row-to-column” conversion cost of fetching data via JDBC (which yields rows that analytical tools then pack into columns). A measurement cited by Dremio is that converting columnar&lt;-&gt;row for JDBC/ODBC can consume 60–90% of the time in data transfer​<br />
DREMIO.COM<br />
; Flight SQL skips that by keeping everything in Arrow format. Moreover, Flight SQL can return result sets partitioned across endpoints, allowing massive parallel retrieval for big queries (if the database supports distributing the query results). The Flight SQL protocol supports features like transaction handling (there are calls for begin/commit) and also passes through database-specific info (e.g. the GetSqlInfo call can retrieve DB-specific capabilities flags). It’s built to be extensible as well – if new metadata or commands are needed, they can be added in future versions in a backwards-compatible way.In implementation, a Flight SQL server may be slightly heavier than a raw Flight server because it must maintain some state: e.g. track prepared statement handles, and possibly manage transactions if those are used. The Arrow Flight SQL spec includes the concept of a server-managed session (potentially with cookies or tokens to maintain context like an open transaction)​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
, but a simple implementation can also ignore sessions and treat each call statelessly (except transactions which need explicit begin/commit tracking).Example: Suppose we integrate Flight SQL with SQLite (a single-file SQL database). We subclass FlightSqlServerBase in C++ to create SQLiteFlightSqlServer. In our override of GetTables (for CommandGetTables), we execute SELECT name, type &hellip; FROM sqlite_master to get table names, convert that to an Arrow RecordBatch (two columns: table name, table type). We then return that as the result for the Flight DoGet. For ExecuteSql (CommandStatementQuery), we execute the query on SQLite (perhaps using SQLite’s C API), then for each row of the result, append to Arrow arrays. Because SQLite is not columnar, we have to copy data into Arrow format, but once that’s done, Arrow takes over for sending it. For a more Arrow-native backend like DuckDB, we could avoid even that copy by using DuckDB’s Arrow interface. The end result: a client (could be Python or Java) can use Flight SQL to query SQLite or DuckDB as if they were a remote SQL service, getting Arrow data back.In conclusion, Arrow Flight SQL brings the efficiency of Arrow Flight to the world of SQL-based data access. Its implementation builds on the strong foundation of Arrow’s columnar format and Flight’s zero-copy streaming RPC. By standardizing how queries and results are handled (and doing so in a language-agnostic way), it allows data engineers to write one client that can query many different databases using the same approach​<br />
VOLTRONDATA.COM<br />
​<br />
VOLTRONDATA.COM<br />
. At the same time, it spares database developers from writing custom protocol drivers – they can leverage the Flight SQL framework and focus on extracting data into Arrow. With broad support across languages (C++, Java, Rust, Go, Python, etc.), Flight SQL is poised to become a high-performance alternative to ODBC/JDBC for analytics, offering both speed and simplicity in accessing big data.References: The technical details above draw from the Apache Arrow project documentation and blog posts, including the Arrow Columnar Format spec​<br />
ARROW.APACHE.ORG<br />
​<br />
WESM.GITHUB.IO<br />
, design discussions on Flight RPC​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
, and the introducing Flight SQL blog post​<br />
ARROW.APACHE.ORG<br />
​<br />
ARROW.APACHE.ORG<br />
, as well as code references from Arrow’s C++ and Rust implementations​<br />
JORISVANDENBOSSCHE.GITHUB.IO<br />
​<br />
ARROW.APACHE.ORG<br />
. These illustrate the architecture and optimizations of Arrow’s memory format and the Flight/Flight SQL layers that build upon it. The convergence of columnar in-memory format and an RPC mechanism tailored to it is what makes Arrow, Flight, and Flight SQL a powerful stack for modern data engineering.</p>







  
    
  
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="Last update">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">March 2, 2025</span>
  </span>

    
    
    
    
  </aside>


  




                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/TFMV" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://www.linkedin.com/in/TFMV" target="_blank" rel="noopener" title="www.linkedin.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.instant", "navigation.tabs", "navigation.indexes", "navigation.top", "search.suggest", "search.highlight", "content.code.copy"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.081f42fc.min.js"></script>
      
    
  </body>
</html>